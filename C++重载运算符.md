# 为什么具有对称性的运算符，通常在重载时声明为普通的非成员函数



在C++中，有些运算符具有对称性，比如加法运算符 +、乘法运算符 * 等。这些运算符的特点是，它们可以接受不同类型的操作数，并且可以交换操作数的位置而不影响结果。例如，对于加法运算符，a + b 和 b + a 的结果是相同的，这就是对称性。

当你重载这些具有对称性的运算符时，通常倾向于将它们声明为非成员函数，而不是类的成员函数。这是因为非成员函数具有更好的对称性和更广泛的适用性。

以下是几个理由：

对称性： 将这些运算符作为非成员函数进行重载更符合对称性。例如，当你重载加法运算符时，如果将其作为成员函数进行重载（例如 a.operator+(b)），它将限制你只能修改左侧的对象。通过将其定义为非成员函数（例如 operator+(a, b)），你可以支持更多的类型组合，比如 a + b 和 b + a。

对称性和可扩展性： 非成员函数能够处理更广泛的操作数类型组合。如果你将二元运算符作为成员函数重载，当左操作数不是类的实例时，你就无法调用这个运算符。而将其定义为非成员函数，你可以处理左右操作数不同类型的情况，比如类对象和内置类型之间的组合。

非成员函数的重载： 非成员函数的重载也允许你在用户定义类型和内置类型之间实现运算符重载。这种情况下，可以通过在命名空间中定义适当的运算符函数来允许用户定义类型和内置类型之间的交互。

示例代码：

```cpp
#include <iostream>

class MyClass {
    int value;
public:
    MyClass(int v) : value(v) {}

    // 如果要将二元运算符 + 作为成员函数重载：
    // MyClass operator+(const MyClass& other) const {
    //     return MyClass(value + other.value);
    // }

    friend MyClass operator+(const MyClass& obj1, const MyClass& obj2) {
        return MyClass(obj1.value + obj2.value);
    }
};

int main() {
    MyClass a(5);
    MyClass b(10);

    MyClass c = a + b; // 调用 operator+ 作为非成员函数重载

    return 0;
}
```
在上述示例中，operator+ 被定义为 MyClass 的友元非成员函数，允许在不同的 MyClass 对象之间执行加法操作。这种实现方式提供了更大的灵活性和对称性。
